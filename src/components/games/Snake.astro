<canvas id="snake-canvas" class="w-full h-full block outline-none" tabindex="0"></canvas>

<script>
    const canvas = document.getElementById('snake-canvas') as HTMLCanvasElement;
    const ctx = canvas.getContext('2d')!;

    // Config
    const GRID_SIZE = 20;
    const BASE_SPEED = 120; // ms per move

    // State
    let snake: {x: number, y: number}[] = [];
    let food: {x: number, y: number} = {x: 0, y: 0};
    let direction = {x: 1, y: 0};
    let nextDirection = {x: 1, y: 0};
    let score = 0;
    let isGameOver = false;
    let lastTime = 0;
    let moveTimer = 0;
    let cols = 0;
    let rows = 0;
    let gameStarted = false;
    let bestScore = 0;

    function getSpeed() {
        // Speed increases as score grows
        return Math.max(50, BASE_SPEED - Math.floor(score / 30) * 10);
    }

    function resize() {
        const parent = canvas.parentElement;
        if (parent) {
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            cols = Math.floor(canvas.width / GRID_SIZE);
            rows = Math.floor(canvas.height / GRID_SIZE);
            if (snake.length === 0) reset();
        }
    }

    function reset() {
        snake = [
            {x: 5, y: 5},
            {x: 4, y: 5},
            {x: 3, y: 5}
        ];
        direction = {x: 1, y: 0};
        nextDirection = {x: 1, y: 0};
        score = 0;
        isGameOver = false;
        gameStarted = false;
        window.updateScore(0);
        spawnFood();
        canvas.focus();
    }

    function spawnFood() {
        let valid = false;
        while (!valid) {
            food = {
                x: Math.floor(Math.random() * cols),
                y: Math.floor(Math.random() * rows)
            };
            valid = !snake.some(s => s.x === food.x && s.y === food.y);
        }
    }

    function gameOver() {
        isGameOver = true;
        if (score > bestScore) bestScore = score;
        window.playGameSound?.('gameOver');
        window.showGameOver(score);
    }

    function update() {
        direction = nextDirection;
        const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};

        // Wall Collision
        if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) {
            gameOver();
            return;
        }

        // Self Collision
        if (snake.some(s => s.x === head.x && s.y === head.y)) {
            gameOver();
            return;
        }

        snake.unshift(head);

        // Eat Food
        if (head.x === food.x && head.y === food.y) {
            score += 10;
            window.updateScore(score);
            window.playGameSound?.('eat');
            spawnFood();
        } else {
            snake.pop();
        }
    }

    function draw() {
        // Background
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
        ctx.lineWidth = 0.5;
        for (let x = 0; x <= cols; x++) {
            ctx.beginPath();
            ctx.moveTo(x * GRID_SIZE, 0);
            ctx.lineTo(x * GRID_SIZE, rows * GRID_SIZE);
            ctx.stroke();
        }
        for (let y = 0; y <= rows; y++) {
            ctx.beginPath();
            ctx.moveTo(0, y * GRID_SIZE);
            ctx.lineTo(cols * GRID_SIZE, y * GRID_SIZE);
            ctx.stroke();
        }

        // Draw Food with glow
        ctx.shadowColor = '#ff5252';
        ctx.shadowBlur = 12;
        ctx.fillStyle = '#ff5252';
        ctx.beginPath();
        ctx.arc(
            food.x * GRID_SIZE + GRID_SIZE/2, 
            food.y * GRID_SIZE + GRID_SIZE/2, 
            GRID_SIZE/2 - 2, 0, Math.PI*2
        );
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw Snake with gradient body
        snake.forEach((s, i) => {
            const t = i / snake.length;
            const r = Math.round(134 - t * 60);
            const g = Math.round(239 - t * 80);
            const b = Math.round(128 - t * 40);
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;

            if (i === 0) {
                // Head: rounded
                ctx.beginPath();
                ctx.roundRect(
                    s.x * GRID_SIZE + 1, s.y * GRID_SIZE + 1,
                    GRID_SIZE - 2, GRID_SIZE - 2, 5
                );
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#fff';
                let ex1 = s.x * GRID_SIZE + GRID_SIZE * 0.3;
                let ey1 = s.y * GRID_SIZE + GRID_SIZE * 0.3;
                let ex2 = s.x * GRID_SIZE + GRID_SIZE * 0.7;
                let ey2 = s.y * GRID_SIZE + GRID_SIZE * 0.3;
                if (direction.x === -1) { ex1 = s.x * GRID_SIZE + GRID_SIZE * 0.3; ex2 = s.x * GRID_SIZE + GRID_SIZE * 0.3; ey2 = s.y * GRID_SIZE + GRID_SIZE * 0.7; }
                if (direction.x === 1) { ex1 = s.x * GRID_SIZE + GRID_SIZE * 0.7; ex2 = s.x * GRID_SIZE + GRID_SIZE * 0.7; ey1 = s.y * GRID_SIZE + GRID_SIZE * 0.3; ey2 = s.y * GRID_SIZE + GRID_SIZE * 0.7; }
                if (direction.y === -1) { ex1 = s.x * GRID_SIZE + GRID_SIZE * 0.3; ey1 = s.y * GRID_SIZE + GRID_SIZE * 0.3; ex2 = s.x * GRID_SIZE + GRID_SIZE * 0.7; ey2 = s.y * GRID_SIZE + GRID_SIZE * 0.3; }
                if (direction.y === 1) { ex1 = s.x * GRID_SIZE + GRID_SIZE * 0.3; ey1 = s.y * GRID_SIZE + GRID_SIZE * 0.7; ex2 = s.x * GRID_SIZE + GRID_SIZE * 0.7; ey2 = s.y * GRID_SIZE + GRID_SIZE * 0.7; }
                ctx.beginPath(); ctx.arc(ex1, ey1, 2.5, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(ex2, ey2, 2.5, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.beginPath();
                ctx.roundRect(
                    s.x * GRID_SIZE + 1.5, s.y * GRID_SIZE + 1.5,
                    GRID_SIZE - 3, GRID_SIZE - 3, 3
                );
                ctx.fill();
            }
        });

        // Speed indicator
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.fillText(`SPD ${Math.round((1 - getSpeed() / BASE_SPEED) * 100 + 100)}%`, canvas.width - 8, 8);

        if (!gameStarted) {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '18px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ðŸ SNAKE', canvas.width/2, canvas.height/2 - 40);
            ctx.font = '10px "Press Start 2P"';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillText('Arrow Keys / Swipe', canvas.width/2, canvas.height/2);
            ctx.fillText('Press any key to start', canvas.width/2, canvas.height/2 + 30);
            if (bestScore > 0) {
                ctx.fillStyle = '#fbbf24';
                ctx.fillText(`BEST: ${bestScore}`, canvas.width/2, canvas.height/2 + 60);
            }
        }
    }

    function loop(timestamp: number) {
        if (isGameOver) return;

        const dt = timestamp - lastTime;
        lastTime = timestamp;

        if (gameStarted) {
            moveTimer += dt;
            if (moveTimer > getSpeed()) {
                update();
                moveTimer = 0;
            }
        }

        draw();
        requestAnimationFrame(loop);
    }

    function startGame() {
        if (!gameStarted && !isGameOver) {
            gameStarted = true;
        }
    }

    // Input
    window.addEventListener('keydown', e => {
        startGame();
        switch(e.key) {
            case 'ArrowUp':
                if (direction.y === 0) nextDirection = {x: 0, y: -1};
                break;
            case 'ArrowDown':
                if (direction.y === 0) nextDirection = {x: 0, y: 1};
                break;
            case 'ArrowLeft':
                if (direction.x === 0) nextDirection = {x: -1, y: 0};
                break;
            case 'ArrowRight':
                if (direction.x === 0) nextDirection = {x: 1, y: 0};
                break;
        }
    });

    // Touch controls (simple swipe)
    let touchStartX = 0;
    let touchStartY = 0;
    canvas.addEventListener('touchstart', e => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        e.preventDefault();
        startGame();
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        e.preventDefault(); // Prevent scrolling
    }, {passive: false});

    canvas.addEventListener('touchend', e => {
        const dx = e.changedTouches[0].clientX - touchStartX;
        const dy = e.changedTouches[0].clientY - touchStartY;
        
        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0 && direction.x === 0) nextDirection = {x: 1, y: 0};
            else if (dx < 0 && direction.x === 0) nextDirection = {x: -1, y: 0};
        } else {
            if (dy > 0 && direction.y === 0) nextDirection = {x: 0, y: 1};
            else if (dy < 0 && direction.y === 0) nextDirection = {x: 0, y: -1};
        }
    });

    window.addEventListener('resize', resize);
    resize();
    requestAnimationFrame(loop);

    window.addEventListener('game-restart', () => {
        reset();
        lastTime = performance.now();
        requestAnimationFrame(loop);
    });
</script>
