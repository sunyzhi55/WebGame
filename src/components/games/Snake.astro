<canvas id="snake-canvas" class="w-full h-full block outline-none" tabindex="0"></canvas>

<script>
    const canvas = document.getElementById('snake-canvas') as HTMLCanvasElement;
    const ctx = canvas.getContext('2d')!;

    // Config
    const GRID_SIZE = 20;
    const SPEED = 100; // ms per move

    // State
    let snake: {x: number, y: number}[] = [];
    let food: {x: number, y: number} = {x: 0, y: 0};
    let direction = {x: 1, y: 0};
    let nextDirection = {x: 1, y: 0};
    let score = 0;
    let isGameOver = false;
    let lastTime = 0;
    let moveTimer = 0;
    let cols = 0;
    let rows = 0;

    function resize() {
        const parent = canvas.parentElement;
        if (parent) {
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            cols = Math.floor(canvas.width / GRID_SIZE);
            rows = Math.floor(canvas.height / GRID_SIZE);
            if (snake.length === 0) reset();
        }
    }

    function reset() {
        snake = [
            {x: 5, y: 5},
            {x: 4, y: 5},
            {x: 3, y: 5}
        ];
        direction = {x: 1, y: 0};
        nextDirection = {x: 1, y: 0};
        score = 0;
        isGameOver = false;
        window.updateScore(0);
        spawnFood();
        canvas.focus();
    }

    function spawnFood() {
        let valid = false;
        while (!valid) {
            food = {
                x: Math.floor(Math.random() * cols),
                y: Math.floor(Math.random() * rows)
            };
            valid = !snake.some(s => s.x === food.x && s.y === food.y);
        }
    }

    function gameOver() {
        isGameOver = true;
        window.showGameOver(score);
    }

    function update() {
        direction = nextDirection;
        const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};

        // Wall Collision
        if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) {
            gameOver();
            return;
        }

        // Self Collision
        if (snake.some(s => s.x === head.x && s.y === head.y)) {
            gameOver();
            return;
        }

        snake.unshift(head);

        // Eat Food
        if (head.x === food.x && head.y === food.y) {
            score += 10;
            window.updateScore(score);
            spawnFood();
        } else {
            snake.pop();
        }
    }

    function draw() {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Food
        ctx.fillStyle = '#ff5252';
        ctx.beginPath();
        ctx.arc(
            food.x * GRID_SIZE + GRID_SIZE/2, 
            food.y * GRID_SIZE + GRID_SIZE/2, 
            GRID_SIZE/2 - 2, 0, Math.PI*2
        );
        ctx.fill();

        // Draw Snake
        ctx.fillStyle = '#4ade80';
        snake.forEach((s, i) => {
            if (i === 0) ctx.fillStyle = '#86efac'; // Head lighter
            else ctx.fillStyle = '#4ade80';
            
            ctx.fillRect(
                s.x * GRID_SIZE + 1, 
                s.y * GRID_SIZE + 1, 
                GRID_SIZE - 2, 
                GRID_SIZE - 2
            );
        });
    }

    function loop(timestamp: number) {
        if (isGameOver) return;

        const dt = timestamp - lastTime;
        lastTime = timestamp;

        moveTimer += dt;
        if (moveTimer > SPEED) {
            update();
            moveTimer = 0;
        }

        draw();
        requestAnimationFrame(loop);
    }

    // Input
    window.addEventListener('keydown', e => {
        switch(e.key) {
            case 'ArrowUp':
                if (direction.y === 0) nextDirection = {x: 0, y: -1};
                break;
            case 'ArrowDown':
                if (direction.y === 0) nextDirection = {x: 0, y: 1};
                break;
            case 'ArrowLeft':
                if (direction.x === 0) nextDirection = {x: -1, y: 0};
                break;
            case 'ArrowRight':
                if (direction.x === 0) nextDirection = {x: 1, y: 0};
                break;
        }
    });

    // Touch controls (simple swipe)
    let touchStartX = 0;
    let touchStartY = 0;
    canvas.addEventListener('touchstart', e => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        e.preventDefault();
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        e.preventDefault(); // Prevent scrolling
    }, {passive: false});

    canvas.addEventListener('touchend', e => {
        const dx = e.changedTouches[0].clientX - touchStartX;
        const dy = e.changedTouches[0].clientY - touchStartY;
        
        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0 && direction.x === 0) nextDirection = {x: 1, y: 0};
            else if (dx < 0 && direction.x === 0) nextDirection = {x: -1, y: 0};
        } else {
            if (dy > 0 && direction.y === 0) nextDirection = {x: 0, y: 1};
            else if (dy < 0 && direction.y === 0) nextDirection = {x: 0, y: -1};
        }
    });

    window.addEventListener('resize', resize);
    resize();
    requestAnimationFrame(loop);

    window.addEventListener('game-restart', () => {
        reset();
        lastTime = performance.now();
        requestAnimationFrame(loop);
    });
</script>
