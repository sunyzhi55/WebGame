<canvas id="breakout-canvas" class="w-full h-full block cursor-none" tabindex="0"></canvas>

<script>
    const canvas = document.getElementById('breakout-canvas') as HTMLCanvasElement;
    const ctx = canvas.getContext('2d')!;

    // Config
    const PADDLE_WIDTH = 100;
    const PADDLE_HEIGHT = 15;
    const BALL_RADIUS = 8;
    const BRICK_ROWS = 5;
    const BRICK_COLS = 8;
    
    // State
    let paddle = { x: 0, y: 0 };
    let ball = { x: 0, y: 0, vx: 0, vy: 0, speed: 6 };
    let bricks: {x: number, y: number, w: number, h: number, active: boolean, color: string}[] = [];
    let score = 0;
    let lives = 3;
    let isGameOver = false;
    let gameStarted = false;
    let levelNum = 1;

    function initBricks() {
        bricks = [];
        const padding = 10;
        const offsetTop = 50;
        const offsetLeft = 35;
        const brickWidth = (canvas.width - (offsetLeft * 2) - (padding * (BRICK_COLS - 1))) / BRICK_COLS;
        const brickHeight = 20;
        
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6'];

        for(let c=0; c<BRICK_COLS; c++) {
            for(let r=0; r<BRICK_ROWS; r++) {
                bricks.push({
                    x: (c * (brickWidth + padding)) + offsetLeft,
                    y: (r * (brickHeight + padding)) + offsetTop,
                    w: brickWidth,
                    h: brickHeight,
                    active: true,
                    color: colors[r]
                });
            }
        }
    }

    function resetBall() {
        ball.x = canvas.width / 2;
        ball.y = canvas.height - 50;
        ball.vx = 0;
        ball.vy = 0;
        gameStarted = false;
    }

    function reset() {
        paddle.x = canvas.width / 2 - PADDLE_WIDTH / 2;
        paddle.y = canvas.height - 40;
        resetBall();
        score = 0;
        lives = 3;
        levelNum = 1;
        ball.speed = 6;
        isGameOver = false;
        window.updateScore(0);
        initBricks();
    }

    function resize() {
        const parent = canvas.parentElement;
        if (parent) {
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            reset();
        }
    }

    function loseLife() {
        lives--;
        if (lives <= 0) {
            isGameOver = true;
            window.playGameSound?.('gameOver');
            window.showGameOver(score);
        } else {
            window.playGameSound?.('error');
            resetBall();
        }
    }

    function drawLives() {
        ctx.font = '14px Arial';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        for (let i = 0; i < lives; i++) {
            ctx.fillText('❤️', 10 + i * 22, 10);
        }
    }

    function drawLevel() {
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.fillText(`LV ${levelNum}`, canvas.width - 10, 10);
    }

    function loop() {
        if (isGameOver) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Paddle with gradient
        const paddleGrad = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + PADDLE_HEIGHT);
        paddleGrad.addColorStop(0, '#60a5fa');
        paddleGrad.addColorStop(1, '#2563eb');
        ctx.fillStyle = paddleGrad;
        ctx.beginPath();
        ctx.roundRect(paddle.x, paddle.y, PADDLE_WIDTH, PADDLE_HEIGHT, 4);
        ctx.fill();

        // Draw Ball with glow
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 12;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw Bricks with rounded corners
        bricks.forEach(b => {
            if (b.active) {
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.roundRect(b.x, b.y, b.w, b.h, 3);
                ctx.fill();
                // Highlight
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.fillRect(b.x, b.y, b.w, b.h / 2);
            }
        });

        drawLives();
        drawLevel();

        if (!gameStarted) {
            ctx.fillStyle = 'white';
            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('CLICK TO START', canvas.width/2, canvas.height/2);
            ctx.font = '10px "Press Start 2P"';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('Mouse/Touch to move paddle', canvas.width/2, canvas.height/2 + 30);
            requestAnimationFrame(loop);
            return;
        }

        // Update Ball
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Wall Collision
        if (ball.x + BALL_RADIUS > canvas.width || ball.x - BALL_RADIUS < 0) {
            ball.vx = -ball.vx;
        }
        if (ball.y - BALL_RADIUS < 0) {
            ball.vy = -ball.vy;
        }
        if (ball.y + BALL_RADIUS > canvas.height) {
            loseLife();
        }

        // Paddle Collision
        if (
            ball.y + BALL_RADIUS > paddle.y &&
            ball.y - BALL_RADIUS < paddle.y + PADDLE_HEIGHT &&
            ball.x > paddle.x &&
            ball.x < paddle.x + PADDLE_WIDTH
        ) {
            ball.vy = -Math.abs(ball.vy);
            const hitPoint = ball.x - (paddle.x + PADDLE_WIDTH/2);
            ball.vx = hitPoint * 0.15;
            window.playGameSound?.('click');
        }

        // Brick Collision
        bricks.forEach(b => {
            if (b.active) {
                if (
                    ball.x > b.x && 
                    ball.x < b.x + b.w && 
                    ball.y > b.y && 
                    ball.y < b.y + b.h
                ) {
                    ball.vy = -ball.vy;
                    b.active = false;
                    score += 10;
                    window.updateScore(score);
                    window.playGameSound?.('match');
                    
                    if (bricks.every(brick => !brick.active)) {
                        levelNum++;
                        initBricks();
                        ball.speed += 0.5;
                        resetBall();
                        window.playGameSound?.('win');
                    }
                }
            }
        });

        requestAnimationFrame(loop);
    }

    // Input - Mouse
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        paddle.x = mx - PADDLE_WIDTH / 2;
        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x > canvas.width - PADDLE_WIDTH) paddle.x = canvas.width - PADDLE_WIDTH;
        if (!gameStarted) ball.x = paddle.x + PADDLE_WIDTH / 2;
    });

    // Input - Touch
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mx = e.touches[0].clientX - rect.left;
        paddle.x = mx - PADDLE_WIDTH / 2;
        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x > canvas.width - PADDLE_WIDTH) paddle.x = canvas.width - PADDLE_WIDTH;
        if (!gameStarted) ball.x = paddle.x + PADDLE_WIDTH / 2;
    }, {passive: false});

    canvas.addEventListener('click', () => {
        if (!gameStarted && !isGameOver) {
            gameStarted = true;
            ball.vy = -ball.speed;
            ball.vx = (Math.random() - 0.5) * 4;
        }
    });

    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        if (!gameStarted && !isGameOver) {
            gameStarted = true;
            ball.vy = -ball.speed;
            ball.vx = (Math.random() - 0.5) * 4;
        }
    }, {passive: false});

    window.addEventListener('resize', resize);
    resize();
    requestAnimationFrame(loop);

    window.addEventListener('game-restart', () => {
        reset();
        requestAnimationFrame(loop);
    });
</script>
