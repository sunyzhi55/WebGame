<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji åˆ‡æ°´æœå¤§ä½œæˆ˜</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* ç¦æ­¢ç§»åŠ¨ç«¯é»˜è®¤è§¦æ‘¸è¡Œä¸º */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .title {
            font-size: 48px;
            font-weight: bold;
            color: #ffeb3b;
            margin-bottom: 20px;
        }
        .score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            text-align: left;
        }
        .lives {
            color: #ff5252;
        }
        .btn {
            pointer-events: auto;
            background: linear-gradient(45deg, #ff9800, #ff5722);
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            font-weight: bold;
        }
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }
        .btn:active {
            transform: scale(0.95);
        }
        #game-over-screen, #start-screen {
            background: rgba(0, 0, 0, 0.7);
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <!-- UI å±‚ -->
    <div id="ui-layer">
        <div class="score-board hidden" id="score-board">
            <div>åˆ†æ•°: <span id="score">0</span></div>
            <div class="lives">ç”Ÿå‘½: <span id="lives">â¤ï¸â¤ï¸â¤ï¸</span></div>
        </div>

        <div id="start-screen">
            <div class="title">ğŸ‰ Emoji åˆ‡æ°´æœ ğŸŒ</div>
            <p style="font-size: 18px; margin-bottom: 30px; color: #ddd;">æ»‘åŠ¨é¼ æ ‡æˆ–æ‰‹æŒ‡åˆ‡æ°´æœï¼Œä¸è¦åˆ‡åˆ°ç‚¸å¼¹ï¼</p>
            <button class="btn" id="start-btn">å¼€å§‹æ¸¸æˆ</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <div class="title">æ¸¸æˆç»“æŸ</div>
            <p style="font-size: 24px; margin-bottom: 20px;">æœ€ç»ˆå¾—åˆ†: <span id="final-score">0</span></p>
            <button class="btn" id="restart-btn">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- æ¸¸æˆé…ç½®ä¸å…¨å±€å˜é‡ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI å…ƒç´ 
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const scoreBoard = document.getElementById('score-board');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const finalScoreEl = document.getElementById('final-score');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');

        // æ¸¸æˆçŠ¶æ€
        let gameState = 'START'; // START, PLAYING, GAMEOVER
        let score = 0;
        let lives = 3;
        let fruits = [];
        let particles = [];
        let bladePoints = [];
        let isMouseDown = false;
        let lastTime = 0;
        let spawnTimer = 0;
        let spawnInterval = 1000; // åˆå§‹ç”Ÿæˆé—´éš” (ms)
        
        // æ°´æœå®šä¹‰
        const FRUIT_TYPES = [
            { emoji: 'ğŸ', color: '#ff5252' },
            { emoji: 'ğŸŒ', color: '#ffeb3b' },
            { emoji: 'ğŸ‰', color: '#4caf50' },
            { emoji: 'ğŸ‡', color: '#9c27b0' },
            { emoji: 'ğŸ', color: '#fdd835' },
            { emoji: 'ğŸ¥', color: '#8bc34a' },
            { emoji: 'ğŸŠ', color: '#ff9800' },
            { emoji: 'ğŸ‘', color: '#ffccbc' }
        ];

        // --- æ ¸å¿ƒç±»å®šä¹‰ ---

        class Fruit {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                // ç‰©ç†å±æ€§
                this.vx = (Math.random() - 0.5) * 8; // æ°´å¹³é€Ÿåº¦
                this.vy = -(Math.random() * 8 + 10); // å‚ç›´å‘ä¸Šé€Ÿåº¦
                this.gravity = 0.25;
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.size = 50; // ç¢°æ’åŠå¾„å‚è€ƒ
                this.active = true;
                this.sliced = false;
                
                // å†³å®šæ˜¯ç‚¸å¼¹è¿˜æ˜¯æ°´æœ
                this.isBomb = Math.random() < 0.15; // 15% å‡ ç‡æ˜¯ç‚¸å¼¹
                
                if (this.isBomb) {
                    this.emoji = 'ğŸ’£';
                    this.color = '#333';
                } else {
                    const type = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
                    this.emoji = type.emoji;
                    this.color = type.color;
                }
            }

            update() {
                // åº”ç”¨é‡åŠ›
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;

                // è¾¹ç•Œæ£€æŸ¥ï¼ˆæ‰å‡ºå±å¹•ï¼‰
                if (this.y > canvas.height + 100) {
                    this.active = false;
                    // å¦‚æœæ˜¯æ°´æœä¸”æ²¡è¢«åˆ‡ï¼Œæ‰£è¡€
                    if (!this.isBomb && !this.sliced && gameState === 'PLAYING') {
                        loseLife();
                    }
                }
            }

            draw() {
                if (!this.active) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // ç»˜åˆ¶ Emoji
                ctx.font = `${this.size * 1.5}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff'; // Emoji ä¸éœ€è¦ fillStyleï¼Œä½†é˜²æ­¢æŸäº›ç¯å¢ƒå¼‚å¸¸
                ctx.fillText(this.emoji, 0, 5); // å¾®è°ƒ y è½´å±…ä¸­
                
                // è°ƒè¯•ç”¨ï¼šç»˜åˆ¶ç¢°æ’åœˆ
                // ctx.beginPath();
                // ctx.arc(0, 0, this.size / 1.5, 0, Math.PI * 2);
                // ctx.strokeStyle = 'red';
                // ctx.stroke();

                ctx.restore();
            }
        }

        // è¢«åˆ‡å¼€çš„æ°´æœåŠä¸ª
        class SlicedFruit {
            constructor(originalFruit, direction) {
                this.x = originalFruit.x;
                this.y = originalFruit.y;
                this.vx = originalFruit.vx + (direction === 'left' ? -2 : 2);
                this.vy = originalFruit.vy;
                this.gravity = 0.3;
                this.rotation = originalFruit.rotation;
                this.rotationSpeed = originalFruit.rotationSpeed + (direction === 'left' ? -0.1 : 0.1);
                this.emoji = originalFruit.emoji;
                this.size = originalFruit.size;
                this.direction = direction; // 'left' or 'right'
                this.active = true;
            }

            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;

                if (this.y > canvas.height + 100) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // æ ¸å¿ƒæŠ€å·§ï¼šä½¿ç”¨ clip() è£å‰ª Emoji å®ç°åˆ‡å¼€æ•ˆæœ
                ctx.beginPath();
                if (this.direction === 'left') {
                    // è£å‰ªå·¦åŠè¾¹
                    ctx.rect(-this.size, -this.size, this.size, this.size * 2);
                } else {
                    // è£å‰ªå³åŠè¾¹
                    ctx.rect(0, -this.size, this.size, this.size * 2);
                }
                ctx.clip();

                ctx.font = `${this.size * 1.5}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 5);

                ctx.restore();
            }
        }

        // æœæ±ç²’å­
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0; // é€æ˜åº¦
                this.decay = Math.random() * 0.02 + 0.01;
                this.color = color;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // ç²’å­é‡åŠ›
                this.life -= this.decay;
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // --- æ¸¸æˆé€»è¾‘å‡½æ•° ---

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // é¼ æ ‡/è§¦æ‘¸äº‹ä»¶
            canvas.addEventListener('mousedown', startSlice);
            canvas.addEventListener('mousemove', moveSlice);
            canvas.addEventListener('mouseup', endSlice);
            canvas.addEventListener('mouseleave', endSlice);
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startSlice(e.touches[0]);
            }, {passive: false});
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                moveSlice(e.touches[0]);
            }, {passive: false});
            canvas.addEventListener('touchend', endSlice);

            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', startGame);

            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function startGame() {
            gameState = 'PLAYING';
            score = 0;
            lives = 3;
            fruits = [];
            particles = [];
            bladePoints = [];
            spawnInterval = 1000;
            updateScoreUI();
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            scoreBoard.classList.remove('hidden');
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            finalScoreEl.innerText = score;
            scoreBoard.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
        }

        function loseLife() {
            lives--;
            updateScoreUI();
            if (lives <= 0) {
                gameOver();
            }
        }

        function updateScoreUI() {
            scoreEl.innerText = score;
            let hearts = '';
            for(let i=0; i<lives; i++) hearts += 'â¤ï¸';
            livesEl.innerText = hearts;
        }

        // --- è¾“å…¥å¤„ç† ---

        function startSlice(e) {
            isMouseDown = true;
            bladePoints = [];
            addBladePoint(e.clientX, e.clientY);
        }

        function moveSlice(e) {
            if (!isMouseDown) return;
            addBladePoint(e.clientX, e.clientY);
            checkCollision(e.clientX, e.clientY);
        }

        function endSlice() {
            isMouseDown = false;
            bladePoints = []; // æŠ¬èµ·æ‰‹æ¸…ç©ºåˆ€å…‰
        }

        function addBladePoint(x, y) {
            bladePoints.push({ x, y, life: 10 }); // life ç”¨äºæ§åˆ¶æ‹–å°¾é•¿åº¦
        }

        // --- ç¢°æ’æ£€æµ‹ä¸åˆ‡æ°´æœ ---

        function checkCollision(mx, my) {
            if (gameState !== 'PLAYING') return;

            for (let i = fruits.length - 1; i >= 0; i--) {
                const f = fruits[i];
                if (f instanceof Fruit && f.active && !f.sliced) {
                    // ç®€å•çš„è·ç¦»æ£€æµ‹ (å¦‚æœé¼ æ ‡ç§»åŠ¨å¤ªå¿«ï¼Œå¯èƒ½éœ€è¦æ”¹è¿›ä¸ºçº¿æ®µä¸åœ†çš„æ£€æµ‹)
                    // è¿™é‡Œä½¿ç”¨æ›´å¹³æ»‘çš„æ£€æµ‹ï¼šæ£€æŸ¥å½“å‰é¼ æ ‡ç‚¹æ˜¯å¦åœ¨åœ†å†…
                    const dx = mx - f.x;
                    const dy = my - f.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < f.size) {
                        sliceFruit(f, i);
                    }
                }
            }
        }

        function sliceFruit(f, index) {
            f.sliced = true;
            f.active = false;

            if (f.isBomb) {
                // åˆ‡åˆ°ç‚¸å¼¹
                createExplosion(f.x, f.y);
                gameOver();
            } else {
                // åˆ‡åˆ°æ°´æœ
                score += 10;
                // æé«˜éš¾åº¦ï¼šåˆ†æ•°è¶Šé«˜ç”Ÿæˆè¶Šå¿«
                if (score % 50 === 0 && spawnInterval > 400) {
                    spawnInterval -= 50;
                }
                updateScoreUI();

                // ç”Ÿæˆä¸¤åŠ
                fruits.push(new SlicedFruit(f, 'left'));
                fruits.push(new SlicedFruit(f, 'right'));

                // ç”Ÿæˆæœæ±
                createSplash(f.x, f.y, f.color);
            }
        }

        function createSplash(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function createExplosion(x, y) {
            // ç‚¸å¼¹ç‰¹æ•ˆï¼šå…¨å±é—ªç™½ + å¤§é‡ç™½è‰²/çº¢è‰²ç²’å­
            for (let i = 0; i < 50; i++) {
                particles.push(new Particle(x, y, i % 2 === 0 ? '#fff' : '#f00'));
            }
            // ç®€å•çš„å±å¹•éœ‡åŠ¨æ•ˆæœï¼ˆè§†è§‰ä¸Šæ¨¡æ‹Ÿï¼‰
            canvas.style.transform = `translate(${Math.random()*20-10}px, ${Math.random()*20-10}px)`;
            setTimeout(() => {
                canvas.style.transform = 'none';
            }, 500);
        }

        // --- æ¸²æŸ“å¾ªç¯ ---

        function gameLoop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;

            // 1. æ¸…ç©ºç”»å¸ƒ
            // ç»˜åˆ¶èƒŒæ™¯ï¼ˆç®€å•çš„å¾„å‘æ¸å˜ï¼‰
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width
            );
            gradient.addColorStop(0, '#333');
            gradient.addColorStop(1, '#111');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. ç”Ÿæˆæ°´æœ
            if (gameState === 'PLAYING') {
                spawnTimer += dt;
                if (spawnTimer > spawnInterval) {
                    spawnTimer = 0;
                    // éšæœºä½ç½®ï¼šåº•éƒ¨ 10% ~ 90% å®½åº¦
                    const x = Math.random() * (canvas.width * 0.8) + (canvas.width * 0.1);
                    fruits.push(new Fruit(x, canvas.height + 50));
                }
            }

            // 3. æ›´æ–°å’Œç»˜åˆ¶æ°´æœ/ç¢ç‰‡
            for (let i = fruits.length - 1; i >= 0; i--) {
                let f = fruits[i];
                f.update();
                f.draw();
                if (!f.active) {
                    fruits.splice(i, 1);
                }
            }

            // 4. æ›´æ–°å’Œç»˜åˆ¶ç²’å­
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update();
                p.draw();
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // 5. ç»˜åˆ¶åˆ€å…‰
            if (bladePoints.length > 0) {
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                
                // ç»˜åˆ¶å…‰æ™•
                ctx.beginPath();
                for (let i = 0; i < bladePoints.length; i++) {
                    let p = bladePoints[i];
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
                ctx.lineWidth = 15;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.stroke();

                // ç»˜åˆ¶æ ¸å¿ƒäº®çº¿
                ctx.beginPath();
                for (let i = 0; i < bladePoints.length; i++) {
                    let p = bladePoints[i];
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
                ctx.lineWidth = 6;
                ctx.strokeStyle = '#fff';
                ctx.stroke();

                // ç§»é™¤æ—§çš„è½¨è¿¹ç‚¹
                if (!isMouseDown && bladePoints.length > 0) {
                    bladePoints.shift(); // å¦‚æœæ²¡æŒ‰ä½ï¼Œå¿«é€Ÿæ¶ˆå¤±
                    bladePoints.shift(); 
                } else if (bladePoints.length > 8) {
                    bladePoints.shift(); // é™åˆ¶æœ€å¤§é•¿åº¦
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // å¯åŠ¨
        init();

    </script>
</body>
</html>