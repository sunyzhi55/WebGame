---

---

<div
  class="flex flex-col items-center justify-center h-full bg-amber-50 text-slate-800 p-4 font-sans"
>
  <div class="flex justify-between items-center w-[400px] mb-4">
    <h2 class="text-6xl font-bold text-slate-700">2048</h2>
    <div class="flex flex-col items-end">
      <div
        class="bg-slate-700 text-white p-2 rounded-md min-w-[100px] text-center"
      >
        <div class="text-xs uppercase font-bold text-slate-300">Score</div>
        <div id="score" class="text-2xl font-bold">0</div>
      </div>
      <button
        id="newGameBtn"
        class="mt-2 px-4 py-2 bg-amber-600 hover:bg-amber-500 text-white font-bold rounded text-sm"
      >
        New Game
      </button>
    </div>
  </div>

  <div class="relative">
    <canvas
      id="gameCanvas"
      width="400"
      height="400"
      class="bg-slate-400 rounded-lg cursor-default"></canvas>
    <div
      id="gameOverOverlay"
      class="hidden absolute inset-0 bg-slate-900/70 flex flex-col items-center justify-center rounded-lg"
    >
      <h3 class="text-4xl font-bold text-white mb-4">Game Over!</h3>
      <button
        id="retryBtn"
        class="px-6 py-3 bg-amber-600 hover:bg-amber-500 text-white font-bold rounded text-xl"
        >Try Again</button
      >
    </div>
  </div>

  <p class="mt-6 text-slate-500 font-medium">
    Use Arrow Keys, WASD, or Swipe to move tiles
  </p>
</div>

<script>
  // @ts-nocheck
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas?.getContext("2d");
  const scoreDisplay = document.getElementById("score");
  const newGameBtn = document.getElementById("newGameBtn");
  const retryBtn = document.getElementById("retryBtn");
  const gameOverOverlay = document.getElementById("gameOverOverlay");

  // If the DOM isn't ready or ids changed, bail out gracefully instead of throwing.
  if (
    !canvas ||
    !ctx ||
    !scoreDisplay ||
    !newGameBtn ||
    !retryBtn ||
    !gameOverOverlay
  ) {
    console.warn("2048 game elements not found; game not initialized");
  } else {
    const GRID_SIZE = 4;
    const CELL_SIZE = 90;
    const GAP = 10;
    const PADDING = 10;

    let grid = [];
    let score = 0;
    let gameOver = false;
    let animationProgress = 1; // 0 to 1
    let previousGrid = []; // For animation (not fully implemented for smooth slide, but for pop)

    const COLORS = {
      0: "#cdc1b4",
      2: "#eee4da",
      4: "#ede0c8",
      8: "#f2b179",
      16: "#f59563",
      32: "#f67c5f",
      64: "#f65e3b",
      128: "#edcf72",
      256: "#edcc61",
      512: "#edc850",
      1024: "#edc53f",
      2048: "#edc22e",
    };

    const TEXT_COLORS = {
      2: "#776e65",
      4: "#776e65",
      others: "#f9f6f2",
    };

    function addNewTile() {
      const emptyCells = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (grid[r][c] === 0) emptyCells.push({ r, c });
        }
      }
      if (emptyCells.length > 0) {
        const { r, c } =
          emptyCells[Math.floor(Math.random() * emptyCells.length)];
        grid[r][c] = Math.random() < 0.9 ? 2 : 4;
      }
    }

    function drawRoundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
    }

    function draw() {
      ctx.fillStyle = "#bbada0";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const val = grid[r][c];
          const x = PADDING + c * (CELL_SIZE + GAP);
          const y = PADDING + r * (CELL_SIZE + GAP);

          ctx.fillStyle = COLORS[val] || "#3c3a32";
          drawRoundedRect(x, y, CELL_SIZE, CELL_SIZE, 6);

          if (val > 0) {
            ctx.fillStyle = val <= 4 ? TEXT_COLORS[val] : TEXT_COLORS.others;
            const fontSize = val > 512 ? 35 : val > 64 ? 45 : 55;
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(val.toString(), x + CELL_SIZE / 2, y + CELL_SIZE / 2);
          }
        }
      }
    }

    function initGame() {
      if (!ctx) return;
      grid = Array(GRID_SIZE)
        .fill(null)
        .map(() => Array(GRID_SIZE).fill(0));
      score = 0;
      gameOver = false;
      scoreDisplay.textContent = "0";
      gameOverOverlay.classList.add("hidden");

      addNewTile();
      addNewTile();
      draw();
    }

    // Movement helpers (explicit per direction)
    function checkGameOver() {
      // Check for empty cells
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (grid[r][c] === 0) return;
        }
      }
      // Check for merges
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (c < GRID_SIZE - 1 && grid[r][c] === grid[r][c + 1]) return;
          if (r < GRID_SIZE - 1 && grid[r][c] === grid[r + 1][c]) return;
        }
      }
      gameOver = true;
      gameOverOverlay.classList.remove("hidden");
      window.playGameSound?.('gameOver');
    }

    // Movement helpers (explicit per direction)
    function moveLeft() {
      let moved = false;
      for (let r = 0; r < GRID_SIZE; r++) {
        let row = grid[r].filter((v) => v !== 0);
        for (let i = 0; i < row.length - 1; i++) {
          if (row[i] === row[i + 1]) {
            row[i] *= 2;
            score += row[i];
            row.splice(i + 1, 1);
            moved = true; // Merge counts as move? Yes.
          }
        }
        while (row.length < GRID_SIZE) row.push(0);
        if (JSON.stringify(grid[r]) !== JSON.stringify(row)) moved = true;
        grid[r] = row;
      }
      return moved;
    }

    function moveRight() {
      let moved = false;
      for (let r = 0; r < GRID_SIZE; r++) {
        let row = grid[r].filter((v) => v !== 0);
        // Process from right to left for merging? Or just reverse, process left, reverse back.
        row.reverse();
        for (let i = 0; i < row.length - 1; i++) {
          if (row[i] === row[i + 1]) {
            row[i] *= 2;
            score += row[i];
            row.splice(i + 1, 1);
          }
        }
        while (row.length < GRID_SIZE) row.push(0);
        row.reverse();
        if (JSON.stringify(grid[r]) !== JSON.stringify(row)) moved = true;
        grid[r] = row;
      }
      return moved;
    }

    function moveUp() {
      let moved = false;
      for (let c = 0; c < GRID_SIZE; c++) {
        let col = [];
        for (let r = 0; r < GRID_SIZE; r++)
          if (grid[r][c] !== 0) col.push(grid[r][c]);

        for (let i = 0; i < col.length - 1; i++) {
          if (col[i] === col[i + 1]) {
            col[i] *= 2;
            score += col[i];
            col.splice(i + 1, 1);
          }
        }
        while (col.length < GRID_SIZE) col.push(0);

        for (let r = 0; r < GRID_SIZE; r++) {
          if (grid[r][c] !== col[r]) moved = true;
          grid[r][c] = col[r];
        }
      }
      return moved;
    }

    function moveDown() {
      let moved = false;
      for (let c = 0; c < GRID_SIZE; c++) {
        let col = [];
        for (let r = 0; r < GRID_SIZE; r++)
          if (grid[r][c] !== 0) col.push(grid[r][c]);

        col.reverse();
        for (let i = 0; i < col.length - 1; i++) {
          if (col[i] === col[i + 1]) {
            col[i] *= 2;
            score += col[i];
            col.splice(i + 1, 1);
          }
        }
        while (col.length < GRID_SIZE) col.push(0);
        col.reverse();

        for (let r = 0; r < GRID_SIZE; r++) {
          if (grid[r][c] !== col[r]) moved = true;
          grid[r][c] = col[r];
        }
      }
      return moved;
    }

    function handleInput(key) {
      if (gameOver) return;
      let moved = false;
      if (key === "ArrowLeft" || key === "a") moved = moveLeft();
      else if (key === "ArrowRight" || key === "d") moved = moveRight();
      else if (key === "ArrowUp" || key === "w") moved = moveUp();
      else if (key === "ArrowDown" || key === "s") moved = moveDown();

      if (moved) {
        scoreDisplay.textContent = score.toString();
        window.playGameSound?.('merge');
        addNewTile();
        draw();
        checkGameOver();
      }
    }

    window.addEventListener("keydown", (e) => {
      if (["ArrowUp", "ArrowRight", "ArrowDown", "ArrowLeft"].includes(e.key)) {
        e.preventDefault();
      }
      handleInput(e.key);
    });

    // Touch/Swipe support
    let touchStartX = 0;
    let touchStartY = 0;
    canvas.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
      e.preventDefault();
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, {passive: false});

    canvas.addEventListener('touchend', (e) => {
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = e.changedTouches[0].clientY - touchStartY;
      const minSwipe = 30;
      if (Math.abs(dx) < minSwipe && Math.abs(dy) < minSwipe) return;

      if (Math.abs(dx) > Math.abs(dy)) {
        handleInput(dx > 0 ? 'ArrowRight' : 'ArrowLeft');
      } else {
        handleInput(dy > 0 ? 'ArrowDown' : 'ArrowUp');
      }
    });

    newGameBtn.addEventListener("click", initGame);
    retryBtn.addEventListener("click", initGame);

    // Ensure init happens after DOM is fully ready
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initGame, { once: true });
    } else {
      initGame();
    }
  }
</script>
